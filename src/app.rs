use clap::{App, AppSettings, Arg, ArgGroup, SubCommand};
use failure::ResultExt;
use futures::prelude::*;
use hyper::service::service_fn;
use hyper::Server;
use std::fs;

use crate::error::{Error, ErrorKind, InitializeErrorReason};

fn create_app() -> App<'static, 'static> {
    App::new("REview")
        .version(env!("CARGO_PKG_VERSION"))
        .author("Petabi, Inc.")
        .setting(AppSettings::SubcommandRequiredElseHelp)
        .subcommand(
            SubCommand::with_name("client")
                .about("Runs REview client modes")
                .arg(
                    Arg::with_name("cluster")
                        .short("c")
                        .long("cluster")
                        .takes_value(true)
                        .value_name("cluster_file")
                        .help("File path to cluster file generated by REmake."),
                )
                .arg(
                    Arg::with_name("model")
                        .short("m")
                        .long("model")
                        .takes_value(true)
                        .value_name("model_file")
                        .required(true)
                        .requires("cluster")
                        .conflicts_with("url")
                        .help("File path to model file generated by REmake."),
                )
                .arg(
                    Arg::with_name("raw")
                        .short("r")
                        .long("raw")
                        .takes_value(true)
                        .value_name("database_dir")
                        .required(true)
                        .requires("cluster")
                        .conflicts_with("url")
                        .help("Directory path to raw database generated by REmake."),
                )
                .arg(
                    Arg::with_name("url")
                        .short("u")
                        .long("url")
                        .takes_value(true)
                        .value_name("http://<hostname>:<port number>")
                        .help("HTTP URL of backend server"),
                )
                .arg(
                    Arg::with_name("auto_labeling")
                        .short("a")
                        .long("auto_labeling")
                        .takes_value(false)
                        .requires("cluster")
                        .conflicts_with("url")
                        .help("Runs REview in auto labeling mode"),
                )
                .group(
                    ArgGroup::with_name("review_option")
                        .args(&["cluster", "url"])
                        .required(true),
                ),
        )
        .subcommand(SubCommand::with_name("reviewd").about("Runs REviewd (http server mode)"))
}

pub fn init() -> Result<(), Error> {
    let matches = create_app().get_matches();
    if let Some(review_matches) = matches.subcommand_matches("client") {
        if let Some(url) = review_matches.value_of("url") {
            let parsed_url = url::Url::parse(url)
                .context(ErrorKind::Initialize(InitializeErrorReason::ClientUrl))?;
            if parsed_url.scheme() != "http"
                || parsed_url.path() != "/"
                || parsed_url.port().is_none()
            {
                return Err(Error::from(ErrorKind::Initialize(
                    InitializeErrorReason::ClientUrl,
                )));
            }
            // TODO: After REview http client mode gets updated,
            //       modify the error handing here to use context()
            let cluster_view = client::http::ClusterView::new(&url);
            match cluster_view {
                Ok(mut cluster_view) => cluster_view.run(),
                Err(e) => {
                    eprintln!("Failed to create a cluster_view: {}", e);
                    std::process::exit(1);
                }
            }
        } else if let Some(cluster) = review_matches.value_of("cluster") {
            let model = review_matches.value_of("model").unwrap();
            let raw = review_matches.value_of("raw").unwrap();
            let mut cluster_view = client::file::ClusterView::new(cluster, model, raw)
                .context(ErrorKind::Initialize(InitializeErrorReason::ClientMode))?;
            cluster_view.run_feedback_mode();
        }
    } else if matches.subcommand_matches("reviewd").is_some() {
        dotenv::dotenv().ok();
        let database_url = std::env::var("DATABASE_URL").expect("DATABASE_URL is not set.");
        let reviewd_addr = std::env::var("REVIEWD_ADDR").expect("REVIEWD_ADDR is not set");
        let etcd_addr = std::env::var("ETCD_ADDR").expect("ETCD_ADDR is not set");
        let docker_host_ip = std::env::var("DOCKER_HOST_IP").expect("DOCKER_HOST_IP is not set");

        if fs::metadata(&database_url).is_err() {
            fs::metadata("/central_repo.db").context(ErrorKind::Initialize(
                InitializeErrorReason::DatabaseFileNotFound,
            ))?;
            fs::copy("/central_repo.db", &database_url).context(ErrorKind::Initialize(
                InitializeErrorReason::DatabaseInitialization,
            ))?;
        }
        let docker_host_addr = format!("{}:8080", docker_host_ip);

        let new_service = move || {
            let etcd_url = format!("http://{}/v3beta/kv/put", etcd_addr);
            let api_service = api_service::ApiService::new(
                &database_url,
                docker_host_addr.as_str(),
                etcd_url.as_str(),
            )
            .map_err(|e| panic!("Reviewd initialization fails: {}", e))
            .and_then(|srv| {
                service_fn(move |req| {
                    api_service::ApiService::request_handler(srv.clone(), req)
                        .then(api_service::ApiService::api_error_handler)
                })
            });
            Box::new(api_service)
        };
        let reviewd_addr = reviewd_addr
            .parse::<std::net::SocketAddr>()
            .context(ErrorKind::Initialize(InitializeErrorReason::REviewdUrl))?;
        let server = Server::bind(&reviewd_addr)
            .serve(new_service)
            .map_err(|e| panic!("Failed to build server: {}", e));

        hyper::rt::run(server);
    }

    Ok(())
}
